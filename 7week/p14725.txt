1. 문제 인식

먹이의 정보개수 N과 N개의 먹이 정보개수는 먹이정보를 K만큼 가질 때, 이 개미굴의 시각화된 구조를 출력하는 문제입니다. 이때, 같은 층에 여러방이 있는 경우, 사전 우선순위로 출력합니다.

2. 문제 유형 파악

문제에서 같은층에 여러방이 있는 경우, 사전 우선순위로 출력하게 끔 합니다. 그러므로 사전(map) 자료구조를 사용해야함을 알 수 있습니다. (map 알고리즘은 사전 우선순위로 정렬됨.)
또한, 각 층의 방을 따라 내려가는 형식으로 문제에서 제시했으므로, DFS 방식으로 탐색합니다.
위로 미루어 볼때, 이 문제는 Trie 알고리즘으로 문제를 해결합니다. (Trie의 find는 DFS 방식으로 처리.)

3. 다이어그램 또는 알고리즘을 나열

    1) 먹이 정보개수를 저장할 정수형 변수 n과 먹이 정보에서 먹이 정보의 개수를 저장할 정수형 변수 k를 선언합니다.
    2) n을 입력받습니다.
    3) Trie 클래스의 주소를 가지는 root 변수에 Trie 클래스를 동적할당합니다.
    4) i가 0부터 n-1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
        (1) k를 입력받습니다.
        (2) string으로 이루어진 배열(vector) tmp를 선언합니다.
        (3) j가 0부터 k-1까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
            [1] tmp[j]를 입력받습니다.
        (4) root가 가지고 있는 클래스의 insert(tmp, 0) 함수를 호출합니다.
    5) root가 가지고 있는 클래스의 dfs(0) 함수를 호출합니다.
    6) delete root를 통해 동적할당을 해제합니다.

    Trie 클래스는 트라이 알고리즘을 수행하기 위한 클래스입니다.

    문자열과 해당 문자열의 하위 노드를 저장하는 맵 자료구조 next를 선언합니다.  (필자가 이해하기에 이는 트리 형태로 구현되는거같음.)

    insert(vector<string>& v, int idx) 함수는 트라이 자료구조에 문자열을 삽입하는 함수입니다.
        idx가 v.size()와 같다면, 문자열의 끝까지 도달한 것이므로, return합니다.

        next.find(v[idx])가 next.end와 같다면, 다음을 수행합니다.       (문자열이 Trie에 존재하지 않는 경우.)
            Trie클래스의 주소를 가지는 새로운 Trie 클래스 trie를 만듭니다.  (하위 Trie 노드를 생성.)
            next->insert({v[idx], trie}) 함수를 수행합니다.      (위에서 만든 하위 trie 노드와 현재 문자열을 넘겨주어 하위 노드에 삽입을 시작함.)

        next[v[idx]]->insert(v, idx + 1) 함수를 수행합니다.   (이미 문자열이 있는 경우 해당 문자열의 아래 노드를 가리켜서 삽입함.)          ex) APPLE
                                                                                                                                         -- APPLE
    
    dfs(int d) 함수는 현재깊이 d 를 인자로 가지는 함수입니다.

    i가 next맵의 각 요소를 반복하는 반복문에서 다음을 반복합니다.
        j가 0부터 d-1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
            "--"를 출력합니다.                      (개미굴의 층만큼 들여쓰기)
        i.first를 출력합니다.   (현재 맵 요소의 문자열)
        i.second->dfs(d + 1) 함수를 수행합니다.     (현재 요소의 하위 노드에 대해 재귀적으로 dfs 함수를 호출합니다. dfs 방식이므로 d+1로 전달하여 깊이를 증가합니다.)
        delete i.second 를 사용해 메모리 할당을 해제합니다.     (이미 사용이 끝났음. why? 위 재귀를 마치고 내려왔기 때문.)