1. 문제 인식

V개의 도시와 E개의 도로, 그 도로의 거리가 주어졌을 때, 최소 사이클의 도로 길이 합을 구하여 출력하는 문제입니다.

2. 문제 유형 파악

문제에서 시작점을 따로 주어주지 않고, 가중치합이 가장 적은 사이클을 찾길 요구합니다.
이는 여러 시작지점에서 시작하여 가중치가 가장 적게 도착할 수 있는 사이클을 찾으면 되는 것으로, 플로이드 워셜 알고리즘을 사용합니다. (why ? 각 지점에서 다음 도시로 가는 경로는 a - > b -> c와 a -> c가 있을 수 있는데 이는 곧 추이 닫침형태를 보인다.
                                                                                                                            이때 가중치를 고려하여 더 짧은 경로를 선택하게 끔하여 원래 위치로 돌아와서 사이클을 이루게 되면 문제가 요구하는 바를 도출해낼 수 있다.
                                                                                                                            근데 사이클을 이루지 못한다면, -1을 출력한다. 플로이드 워셜은 그래프에서 기본값을 INF로 설정하고, 입력값을 그래프에 넣어서 세팅된 그래프를 바탕으로
                                                                                                                            돌기 때문에 사이클이 이루어지지 못한다면 INF를 담게됨.)

3. 다이어그램 또는 알고리즘을 나열

    1) 마을의 수를 담을 정수형 변수 v, 도로의 개수를 담을 정수형 변수 e, a마을에서 b마을로 가는 가중치 c를 담을 정수형변수 a, b, c를 선언한다.
    2) 경로가 없음을 표시하기 위한 정수형 변수 INF를 선언하고 1e9로 초기화한다.
    3) 그래프 정보를 담기위한 이차원배열 graph를 선언한다.
    4) v와 e를 입력받는다.
    5) i가 1부터 v까지 증가하며 반복하는 반복문에서 다음을 반복한다.
        (1) k가 1부터 v까지 증가하며 반복하는 반복문에서 다음을 반복한다.
            [1] i와 k가 다르다면, graph[i][k]에 INF를 대입한다.         (기본값 세팅)
            [2] i와 k가 같다면, graph[i][k]에 0을 대입한다.         (자기 자신은 가중치가 0 문제 특성상 방문할 일이 없어서 이 코드가 없어도 가능함.)
    6) i가 0부터 e-1 까지 증가하며 반복하는 반복문에서 다음을 반복한다.
        (1) a, b, c를 입력받는다.
        (2) graph[a][b]에 c를 대입한다. (a마을에서 b마을로 가는 가중치 c)
    7) floyd() 함수를 호출한다.
    8) 결과를 저장할 정수형 변수 res를 선언하고, INF로 정의한다.    (최소값을 찾아야하므로 가장 큰값으로 세팅)
    9) i가 1부터 v까지 증가하며 반복하는 반복문에서 다음을 반복한다.
        (1) k가 1부터 v까지 증가하며 반복하는 반복문에서 다음을 반복한다.
            [1] i와 k가 같다면 continue로 반복문 상위로 분기한다.   (자기 자신은 방문할 필요가없다.)
            [2] res에 res와 graph[i][k] + graph[k][i]의 값 중 작은값을 대입한다.            (graph[i][k] + graph[k][i]를 대입하는 이유는 문제에서 사이클을 요구했으므로, 저 값을 넣어줘야함. 이때 사이클을 이루지 않는다면 a + INF 이므로 다른 최소값이 존재하지 않을때, 결과가 INF일 수 밖에없다.)
    10) res가 INF라면 -1을 출력하고, 아니라면 res를 출력한다.

    floyd함수는 문제 유형 파악에서 서술했듯이, a -> c와 a -> b + b -> c 의 가중치중 작은것을 찾아 대입해주는 함수입니다.

    i가 1부터 v까지 증가하며 반복하는 반복문에서 다음을 반복합니다. (i는 경유지 위 식에서 b의 역할)
        k가 1부터 v까지 증가하며 반복하는 반복문에서 다음을 반복합니다. (k는 시작지점 위 식에서 a의 역할)
            l이 1부터 v까지 증가하며 반복하는 반복문에서 다음을 반복합니다. (l은 도착지점 위 식에서 c의 역할)
                graph[k][l]이 graph[k][i] + graph[i][l] 보다 크다면, graph[k][l]에 graph[k][i] + graph[i][l]을 대입합니다.  (직통으로 가는것보다, 경유해서 가는 경우가 가중치가 적기때문에)