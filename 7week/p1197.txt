1. 문제 인식

입력으로 그래프가 주어졌을 때, 그 그래프의 최소 신장 트리의 가중치를 출력하는 문제입니다.

2. 문제 유형 파악

주어진 그래프로 최소 신장 트리를 생성하여, 가중치 합을 구합니다.
이때 간선은 최대 100,000개 까지 주어지므로, Prim 알고리즘을 통해 문제를 해결합니다.

3. 다이어그램 또는 알고리즘을 나열

    1) 정점의 개수를 담을 정수형 변수 v, 간선의 개수를 담을 정수형 변수 e, 그리고 간선의 정보를 나타내는 정수형 변수 a, b, weigth를 선언한다. (a, b, weigth는 각각 a번 정점과 b번정점이 weight의 가중치로 연결됨을 의미)
    2) 최소신장트리를 구해야하므로 최소힙을 선언하고 그래프의 정보를 저장할 인접리스트를 선언함. (이 인접리스트는 각 요소를 pair쌍으로 저장함. why? 도착지점과 가중치를 저장해야하기 때문.)
    3) 각 정점의 방문여부를 저장할 visited 1차원 배열을 선언한다.
    4) v, e를 입력받는다.
    5) i가 0부터 e-1 까지 증가하며 반복하는 반복문에서 다음을 반복한다.
        (1) a, b, weigth를 입력받는다.
        (2) graph[a]에 {b, weight}를 push한다.  (a에서 b로 가는 간선은 weight의 가중치로 연결됨.)
        (3) graph[b]에 {a, weight}를 push한다.  (b에서 a로 가는 간선은 weight의 가중치로 연결됨. 위와 같으므로 무방향그래프(양방향))
    6) Prim 함수의 리턴값을 출력한다.

    Prim함수는 정점의 위치 start를 인자로 가지는 함수입니다.
    이 함수에서 최소 신장 트리의 가중치를 구하여 리턴해야하므로 이를 저장할 res 정수형 변수를 선언합니다. 그리고 0으로 초기화합니다.
    최소힙에 {0, start} 를 push합니다. (처음 함수가 실행될 때는 시작 정점부터 진행하기 때문에 그 정점은 가중치가 0입니다.)

    최소힙이 공백이아니라면 다음 내용을 반복합니다.
        도착정점을 저장할 start 정수형 변수에 최소힙의 top의 second 값을 저장합니다.
        가중치를 저장할 value 정수형 변수에 최소힙의 top의 first 값을 저장합니다.
        최소힙에서 pop을 수행합니다. (값은 위에서 가져왔으므로 버려줌)

        visited[start]가 true라면 continue를 통해 while문의 상위로 분기합니다. (방문한 노드는 다시 갈필요없음. 방문한 노드를 다시가게되면 추이관계가 생길 수 있어 이는 최소 신장 트리라고 보기 어려움.)

        (위 조건에서 분기를 안했을때)
        visited[start]를 true로 정의함.
        ans에 value값을 더함. (해당 도착정점까지 도달하는 가중치의 합을 저장)

        i가 0부터 graph[start]의 사이즈 - 1 까지 증가하며 반복하는 반복문에서 다음을 반복함.
            int, int pair쌍을 저장하는 next 변수에 graph[start][i]를 저장함. (인접리스트에서 다음 노드를 방문하는 과정)
            visited[next.first] 가 true라면 continue를 통해 for문 상위로 분기함. (이유는 위의 분기문과 동일)
            (위 조건에서 분기를 안했을 때)
            최소힙에 {next.second, next.first} 를 push함.


    이렇게 prim함수가 작성되면 다익스트라 방식을 활요해 최소 신장 트리의 가중치합을 구할 수 있습니다. (우선순위 큐를 기반으로 순회하기 때문에 다익스트라 알고리즘이 사용됐다고 볼 수 있음. 왜 다익스트라를 쓰는가 ? 일반적인 노드의 데이터값이 아닌 가중치를 신경써서 동작하여야 하기 때문. pair쌍으로 정렬할 때 first를 기준으로 정렬이된다. 위 코드에서 최소힙의 first로는 가중치가 들어감.)
    함수의 while문안의 for문을 통해 인접리스트에 있는 노드들을 최소힙에 push하고 while문의 분기조건문을 통해 방문하지 않는 노드들의 가중치의 합을 구하므로, 최소 신장 트리의 가중치 합이 구해진다고 볼 수 있음. (이미 최소힙(우선순위 큐)로 구현했기에 최소 신장 트리의 가중치합이 도출됨.)