1. 문제 인식

노드의 수 n과 부모 노드와 자식 노드로 이루어진 간선 정보를 입력받고, 공통 조상을 구할 두 노드를 입력 받았을 때 두 노드의 공통 조상을 찾는 문제입니다.

2. 문제 유형 파악

문제에서 두 노드와 가장 가까운 공통 조상을 출력하라고 명시되어 있습니다. 따라서, 최소 공통 조상(LCA) 알고리즘을 통해 문제를 해결합니다.
이 알고리즘을 사용하기 위해, 각 노드의 부모 노드 정보와 높이 정보를 찾아야 할 필요성이 있습니다.

3. 다이어그램 또는 알고리즘을 나열

    1) 테스트 케이스의 개수를 저장할 t를 입력받는다.
    2) 각 노드들의 부모 노드 인덱스를 저장할 parent 정수형 배열과 각 노드의 깊이를 저장할 depth 정수형 배열을 만든다.
    3) depth 배열을 1로 초기화해준다. (깊이를 최소 1로 고정.)
    4) i가 0 부터 t-1까지 증가하며 반복하는 반복문에서 다음을 반복한다.
        (1) 노드의 수를 저장할 n을 입력받는다.
        (2) k가 0부터 n-2 까지 증가하며 반복하는 반복문에서 다음을 반복한다.
            [1] 간선 정보 a, b를 입력받는다. (a가 b의 부모)
            [2] parent[b]에 a를 대입한다. (a가 b의 부모기 때문에)
        (3) k가 1부터 n까지 증가하며 반복하는 반복문에서 다음을 반복한다.
            [1] setDepth(k, parent, depth) 함수를 호출하여 각 노드의 깊이를 찾는다.
        (4) 가장 가까운 공통 조상을 구할 두 노드를 각각 t1, t2 정수형 변수에 입력받는다.
        (5) LCA(t1, t2, parent, depth) 함수의 결과값을 출력한다.
        (6) depth 배열을 1로 초기화하고, parent 배열을 0으로 초기화 해준다.


    setDepth 함수는 노드 인덱스 a와 부모 노드 인덱스를 저장하는 parent 배열, 깊이를 저장하는 depth 배열을 인자로 가지는 함수로, 깊이를 찾아주는 함수입니다.
    a의 부모 노드가 0. 즉 부모 노드가 없을 시, 바로 리턴합니다.
    그게 아니라면, setDepth(parent[a], parent, depth) 로 부모 노드가 0일때 까지 재귀적으로 올라갑니다. (트리에서 위로 올라가는 부분)
    부모 노드가 0이되어 리턴되면 depth[a] 에 depth[parent[a]] + 1 을 대입해줍니다. (부모 노드의 깊이 + 1 을 자식 노드의 깊이에 넣는 부분)

    LCA 함수는 가장 가까운 공통 조상을 구할 두 노드 x와 y, 부모 노드 인덱스를 저장하는 parent 배열, 깊이를 저장하는 depth 배열을 인자로 가지는 함수로, 가장 가까운 공통 조상을 찾아 리턴하는 함수입니다.
    노드 x의 깊이가 노드 y의 깊이보다 크다면, x에 parent[x]를 대입합니다. (깊이를 올려 같게 만들어줌.)
    노드 y의 깊이가 노드 x의 깊이보다 크다면, y에 parent[y]를 대입합니다. (이하 동문)
    x와 y가 같지 않다면, x는 parent[x]를 y는 parent[y]를 대입합니다. (깊이를 같게 만들어준 이후 실행하므로, 같이 올려주면서 공통 조상을 찾음.)
    x 혹은 y를 리턴해줍니다. (어차피 둘이 같음.)