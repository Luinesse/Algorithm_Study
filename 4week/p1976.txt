1. 문제 인식

도시의 수 n과 여행 계획에 속한 도시 m이 주어집니다. 이때 각 도시들의 연결 정보를 입력받은 후, 여행 계획을 입력받습니다. 그 여행 계획이 연결 정보에 의해 가능한 여행 계획인지 찾아내는 문제입니다.

2. 문제 유형 파악

각 도시의 연결 정보를 입력받을 때, 각 도시들이 이어진다면 하나의 집합으로 묶을 수 있습니다. ex) 1-2, 2-3 = 1-2-3
그러므로 연결된 도시들을 하나의 집합으로 묶어주고, 여행 계획으로 주어진 도시들의 집합을 찾아내어 모두 같은지 비교하면 가능한 여행 계획인지 파악하는게 가능하므로,
유니온 파인드 알고리즘을 통해서 문제를 해결합니다.

3. 다이어그램 또는 알고리즘을 나열

    1) 각 도시들의 집합관계를 저장할 city 정수형 배열과 집합의 결과를 저장할 res배열을 만든다.
    2) 도시의 수 n과 여행 계획에 속한 도시의 수 m을 입력받는다.
    3) i가 1부터 200까지 증가하며 반복하는 반복문에서 city[i]에 i를 대입한다. (각 도시들의 초기값 설정. 자기자신이 집합 = 반사관계)
    4) 입력값을 저장할 tmp 정수형 변수를 만든다.
    5) i가 1부터 n까지 증가하며 반복하는 반복문에서 다음을 반복한다.
        (1) k가 1부터 m까지 증가하며 반복하는 반복문에서 다음을 반복한다.
            [1] 연결 정보를 tmp에 입력받는다.
            [2] tmp가 1이라면, Union 함수를 호출한다.
    6) res 배열의 첫번째를 담을 prev 정수형 변수를 만든다.
    7) i가 1부터 m까지 증가하며 반복하는 반복문에서 다음을 반복한다.
        (1) 여행 계획을 tmp에 입력받는다.
        (2) res[i] 에 Find(tmp) 함수의 리턴 값을 대입한다.
        (3) i가 1이라면, prev에 Find(tmp) 함수의 리턴 값을 대입한다.
        (4) (3)의 조건에 부합하지 않았다면, prev 값과 res[i]값을 비교해 다르다면 NO를 출력하고 프로그램을 종료한다.
    8) YES를 출력한다.

    Find함수는 인자로 key값을 받고, key값이 속한 집합을 리턴하는 함수입니다.
    key값과 city[key]의 값이 같다면, key를 그대로 리턴합니다.
    그게 아니라면, city[key]값으로 다시 Find 함수를 호출하여, key가 속해있는 집합을 재귀적으로 찾아 그 값을 리턴합니다.

    Union함수는 인자로 합치기 위한 두 개의 정수 a,b 를 입력받습니다.
    a와 b가 속해있는 집합을 Find함수로 찾은 후, 두 집합이 다르다면, b가 속해있는 집합에 a를 포함합니다.
    ex) 1은 1이라는 집합, 2는 2라는 집합. 둘을 병합하면, 1은 2라는 집합, 2는 2라는 집합.
        위 문제로 해석하면 1은 2로 가는 길이 있음. 2는 2로 가는 길이므로 이 루트에서 1->2 라는 여행 경로가 나옴.