1. 문제 인식

n개의 정점을 가지는 이진 트리의 중위 순회와 후위 순회를 입력으로 받고 전위 순회값을 구하는 문제입니다.

2. 문제 유형 파악

후위 순회 결과식의 마지막은 항상 루트 노드인점을 이용하여 후위 순회 결과식과 중위 순회 결과식을 루트 노드로 분할 하여 전위 순회를 찾을 수 있습니다. 따라서 이 문제는 분할정복을 통하여 해결할 수 있습니다.

ex) 중위 순회 식 : 1 2 3 4 5 6 7 8 9 10
    후위 순회 식 : 1 3 2 5 7 6 4 9 10 8 (마지막인 8이 루트 노드)
    
    중위 순회 식을 8을 기준으로 분할.
    1 2 3 4 5 6 7 (8) 9 10  여기서 왼쪽 서브 트리의 노드 개수를 이용해 후위 순회 식도 분할.
    1 3 2 5 7 6 4 (분할) 9 10 8     후위 순회 식 = 왼쪽 서브트리, 오른쪽 서브트리, 루트 노드 이므로 중위 순회에서 루트 노드를 기준으로 왼쪽 서브트리, 오른쪽 서브트리로 나누어 각각의 개수는 후위 순회 식에서 왼쪽 서브트리, 오른쪽 서브트리 개수와 같으므로 분할이 가능함.

    위 처럼 분할 된것을 기준으로 왼쪽 서브 트리 부터 분할. 이를 재귀적으로 수행.

3. 다이어그램 또는 알고리즘을 나열

    1) 중위순회식을 담을 inOrder 배열과 후위순회식을 담을 postOrder 배열, inOrder 배열 각 원소의 인덱스 위치를 담을 tmp 배열을 선언한다. (인덱스 위치를 가지고 있어야 그 위치를 바탕으로 중위 순회 식 분할이 가능함.)
    2) n을 입력받고, i가 0부터 n-1까지 증가하며 반복하는 반복문에서 inOrder[i]를 입력받음.
    3) i가 0부터 n-1까지 증가하며 반복하는 반복문에서 postOrder[i]를 입력받음.
    4) i가 0부터 n-1까지 증가하며 반복하는 반복문에서 tmp[inOrder[i]]에 i를 대입함. (각 원소의 인덱스 저장.)
    5) 인자로 중위 순회의 첫번째, 마지막 위치와 후위 순회의 첫번째, 마지막 위치를 받는 preOrder 함수를 실행함.

    preOrder 함수는 더이상 분할 할 원소가 없을때 까지 수행함. 따라서, inOrder의 첫번째 인덱스 위치가 마지막 인덱스 위치보다 커졌거나, postOrder의 첫번째 인덱스 위치가 마지막 인덱스 위치보다 커지면 return 한다.
    후위 순회 식의 마지막 원소를 저장할 root 정수형 변수를 선언하여 postOrder[postEnd] 를 대입한다. (마지막은 항상 루트노드)
    중위 순회 식에서 루트 노드의 인덱스를 저장할 정수형 변수 idx를 선언하여 tmp[root] 를 대입한다.
    식을 분할하기 위해 왼쪽 서브트리의 원소 개수를 저장할 정수형 변수 leftCnt를 선언하여 idx - inFirst를 대입한다.
    루트 노드를 출력하고 preOrder(inFirst,idx-1,postFirst,PostFirst + leftCnt - 1) 함수를 호출하여 왼쪽 서브트리에 대해 위 작업을 수행한다.
    왼쪽 서브트리가 끝나면 preOrder(idx + 1, inEnd, postFirst + leftCnt, postEnd - 1) 함수를 호출하여 오른쪽 서브트리에 대해 위 작업을 수행한다.