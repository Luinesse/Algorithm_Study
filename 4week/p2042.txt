1. 문제 인식

n개의 수가 주어졌을 때, 수의 변경이 빈번히 일어나고, 그 중간의 어떤 구간의 합을 구하는 문제입니다.

2. 문제 유형 파악

입력값이 2^63승까지 주어지므로 sum에 배열 요소를 더하여 결과를 구하는 것은 시간초과가 발생할 수 있습니다. 따라서 각 구간 별로 합을 미리 구해두어 값의 업데이트와 구간의 합을 구하는 연산을 O(log n)만에 수행이 가능한 세그먼트 트리를 활용하여 문제를 해결합니다.

3. 다이어그램 또는 알고리즘을 나열

    1) 수를 저장할 arr 정수형 배열과 각 구간의 합을 저장할 segTree 정수형 배열을 선언한다.
    2) 수의 개수 n과 수의 변경 연산의 횟수인 m, 구간의 합을 구하는 횟수인 k를 입력받는다.
    3) i가 0부터 n-1까지 증가하며 반복하는 반복문에서 수를 입력받아 arr[i]에 대입한다.
    4) Init() 함수를 호출하여 세그먼트 트리를 만든다.
    5) 연산을 위해서 a, b, c 정수형 변수들을 선언하고 i가 0부터 m + k - 1까지 증가하며 반복하는 반복문에서 다음을 반복한다. (m + k번이 연산을 수행할 횟수라서 m + k - 1까지.)
        (1) 연산을 입력받아 a, b, c에 대입한다.
        (2) a가 1이라면, 값이 바뀐 후의 차 (c - arr[b - 1]) 를 tmp 정수형 변수에 저장하고, arr[b-1]에 c를 대입한 후 update() 함수를 호출하여 각 노드에 tmp 값만큼 더해준다. (값이 바뀌었으므로, 그 구간을 포함하는 모든 노드의 값이 똑같이 더해져야 하므로 tmp에 저장해두어서 update() 함수를 수행.)
        (3) (2)의 조건에 부합하지 않는다면, subSum() 함수의 리턴값을 출력한다. (1은 값을 변경, 2는 구간합 출력이기 때문.)

    Init 함수는 세그먼트 트리를 만드는것으로 인자로 시작 인덱스인 start, 끝 인덱스인 end, 노드번호 nodeNum을 가지고 수행합니다.
    자기 자신의 구간합을 구할 땐, start와 end가 같으므로 이 경우 segTree[nodeNum]에 arr[start]를 대입하여 리턴한다. (segTree[nodeNum]을 리턴해야 아래에서 재귀적으로 계산할 때, 구간별로 합을 구해놓는게 가능함.)
    위 조건에서 걸리지 않았을 경우, mid 정수형 변수에 (start + end) / 2를 대입합니다. (이분탐색의 방식으로 리프노드만 남을때까지 분할.)
    segTree[nodeNum]에 Init(start, mid, nodeNum * 2) + Init(mid + 1, end, nodeNum * 2 + 1)을 대입하여 리턴합니다. (이진트리이기때문에, nodeNum이 각각 * 2, * 2 + 1로 나타남.)

    subSum 함수는 현재 노드의 시작인 start, 끝인 end, 노드번호 nodeNum, 구간 합의 범위 시작인 left, 범위 끝인 right를 인자로 가지는 함수입니다.
    left가 end보다 크거나, right가 start보다 작아지면 0을 반환합니다. (범위를 벗어나서)
    left가 start보다 작거나 같고 end가 right보다 작거나 같으면 segTree[nodeNum]을 리턴합니다. (현재 노드가 구할려는 노드 범위에 포함되는 경우엔 더 분할할 필요가 없이 그 구간의 합을 주면 되므로 return)
    위 조건에서 걸리지 않았을 경우, mid 정수형 변수에 (start + end) / 2를 대입합니다.
    이후 subSum(start, mid, nodeNum * 2, left, right) + subSum(mid + 1, end, nodeNum * 2 + 1, left, right)를 리턴합니다. (두개의 subSum 함수가 범위에 포함될 때 까지 재귀적으로 반복함.)

    update 함수는 시작 인덱스인 start, 끝 인덱스인 end, 노드번호 nodeNum, 바뀌어질 노드의 인덱스인 targetIdx, 각 노드에 더해져야 할 값인 val로 인자를 가집니다.
    targetIdx가 start보다 작거나, end보다 크면 리턴합니다. (범위 벗어남.)
    segTree[nodeNum] 에 val을 더한값을 segTree[nodeNum]에 대입합니다. (val은 바꿀 값 - 바뀌어질 값으로 이때 발생한 차를 상위 노드에 갱신해주어야 하므로 이 작업을 수행.)
    start와 end가 같다면 리턴합니다. (리프노드에 도달.)
    위 함수들과 같이 mid 정수형 변수에 (start + end) / 2를 대입합니다.
    이후 update(start, mid, nodeNum * 2, targetIdx, val);   update(mid + 1, end, nodeNum * 2 + 1, targetIdx, val); 을 수행합니다. (갱신을 위해서 수행.) 