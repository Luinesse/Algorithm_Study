1. 문제 인식

그래프가 입력으로 주어졌을때, 이분 그래프 인지 판별하는 문제입니다.

2. 문제 유형 파악

이분 그래프는 그래프의 정점의 집합을 두개로 분할하여 각 집합의 정점끼리는 서로 인접하지 않도록 분할해야합니다.
따라서, 집합 1의 원소를 선택하면 반드시 다음 노드는 집합 2의 원소로의 간선이 있는 형태가 됩니다. (집합 2의 원소를 선택하면 집합 1의 원소로의 간선이있음.)
그렇기 때문에, DFS 혹은 BFS 탐색으로 방문한 노드의 집합을 확인하면서 탐색하면 이 그래프가 이분 그래프인지 판별할 수 있습니다.

3. 다이어그램 또는 알고리즘을 나열

    1) 그래프의 정보를 저장할 graph int벡터형 배열을 선언한다. (= 인접리스트 형태)
    2) 방문정보를 저장할 visited 정수형 배열을 선언한다.
    3) 테스트 케이스의 개수와 정점, 간선의 수, 간선의 정보를 저장할 n, v, e, x, y 정수형 변수를 선언한다.
    4) n을 입력받고, i가 0부터 n-1 까지 증가하며 반복하는 반복문에서 다음을 반복한다.
        (1) v와 e를 입력받는다.
        (2) k가 0부터 e-1 까지 증가하며 반복하는 반복문에서 다음을 반복한다.
            [1] x와 y를 입력받는다.
            [2] graph[x]행에 y를 push한다.
            [3] graph[y]행에 x를 push한다.
        (3) k가 0부터 v-1 까지 증가하며 반복하는 반복문에서 다음을 반복한다.
            [1] visited[k]가 0이라면, dfs(k)를 수행한다.
        (4) isPos의 리턴결과가 참이라면, YES를 출력한다.
        (5) (4)의 조건이 거짓이라면, NO를 출력한다.
        (6) k가 0부터 v까지 증가하며 반복하는 반복문에서 graph[k].clear()를 수행한다. (벡터값 초기화)
        (7) k가 0 부터 20000까지 증가하며 반복하는 반복문에서 visited[k]를 0으로 초기화한다.

    dfs함수는 start를 인자로 받아 수행하는 그래프 탐색 함수입니다. (깊이우선탐색)
    visited[start]가 0이라면, visited[start]를 1로 정의합니다. (집합에 속해있지 않다면 일단 1의 집합에 넣음)
    그래프 해당 행의 인접리스트 길이를 구해 gSize에 정의합니다. (graph[start].size())
    i가 0부터 gSize - 1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
        다음으로 방문할 노드를 할당합니다. (next = graph[start][i])
        visited[next]가 0이라면, visited[start]가 1인지 2인지 검사합니다. 1이라면, 2를 삽입하고 2라면 1을 삽입합니다. (이분 그래프의 형태를 만들어줘야함.)
        이후 dfs(next)를 수행합니다.

    isPos함수는 해당 그래프가 이분그래프인지 판별해서 boolean타입으로 반환해주는 함수입니다.
    k가 1부터 k까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
        그래프 해당 행의 인접리스트 길이를 구해 gSize에 정의합니다. (graph[k].size())
        l이 0부터 gSize - 1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
            다음으로 방문할 노드를 할당합니다. (next = graph[k][l])
            visited[k]와 visited[next]가 같다면 false를 리턴합니다. (같은 집합의 원소끼리 인접하기 때문.)
    true를 리턴합니다.