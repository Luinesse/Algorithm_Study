1. 문제 인식

N명의 사람을 N/2로 나누어서 두개의 팀으로 나눌때, i번 사람과 j번 사람이 같은 팀에 속했을 때 팀에 부여되는 능력치를 N X N 표에 조사해서 작성해둡니다.
이때, 두개의 팀의 능력치 차이가 최소로 나게하려할때, 능력치 차이의 최솟값을 구하여 출력하는 문제입니다.

2. 문제 유형 파악

능력치 표에서 모든 경우의 수를 조사하여야 현재 인원에서 능력치 차이의 최소값을 알 수 있습니다. 따라서, 백트래킹 방식으로 문제를 해결합니다.
(현재까지 구해진 최소값보다 큰값은 배제하여도 되기 때문에 브루트포스 알고리즘보다 백트래킹이 더 적합함.)

3. 다이어그램 또는 알고리즘을 나열

    1) 인원수를 저장할 정수형 변수 n과 능력치를 저장할 score 정수형 2차원배열, 팀이 정해졌는지 판단할 boolean형 1차원배열, 최소값을 저장할 minValue를 선언합니다. 여기서 minValue는 최소값을 담아야하기 때문에 임의의 큰값을 저장해둡니다.
    2) n을 입력받는다.
    3) i가 0부터 n-1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
        (1) k가 0부터 n-1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
            [1] 능력치를 입력받아 score[i][k]에 저장합니다.
    4) team(0,0)을 호출합니다.  (인자는 인덱스와 카운트로, 0번째부터 완전탐색을 시작하고, 전체 N중의 반만 팀에 포함시키면 나머지는 상대팀에 포함되므로 cnt값을 인자로 받아 사용합니다.)
    5) minValue를 출력합니다.

    team(int idx, int cnt)는 인자로 idx와 cnt를 가지는 함수입니다. (인자의 의미는 위에서 서술)
    start팀원의 인덱스값을 저장할 벡터 start를 선언합니다.(정수를 저장함)
    link팀원의 인덱스값을 저장할 벡터 link를 선언합니다.(이하동문)
    start팀원들의 능력치합을 저장할 stScore를 선언하고 0으로 초기화합니다.
    link팀원들의 능력치합을 저장할 liScore를 선언하고 0으로 초기화합니다.

    cnt가 n/2와 같다면 다음을 수행합니다.
        i가 0부터 n-1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
            check[i]가 참이라면, start에 i를 push합니다.                        (아래에서 서술할 조건문에서 팀을 갈라두고, 조건에 맞춰 그 팀원들의 인덱스를 저장.)
            check[i]가 거짓이라면, link에 i를 push합니다.
        i가 0부터 (n/2) - 1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
            k가 0부터 (n/2) - 1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
                stScore에 score[start[i]][start[k]]를 더합니다.         (각 팀원 인덱스의 능력치값을 더해서 저장함.)
                liScore에 score[link[i]][link[k]]를 더합니다.
        stScore - liScore의 절대값이 minValue보다 작다면, minValue에 그 절대값을 저장합니다.
        현재 함수를 종료합니다.
    i가 idx부터 n-1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
        check[i]가 참이라면, i를 1 증가하고 해당 반복문의 시작점으로 분기합니다.            (이미 팀이 정해졌기 때문에 배제함.)
        check[i]가 거짓이라면, check[i]를 true로 정의하고, team(i, cnt + 1)을 호출합니다. 그 이후 check[i]를 false로 정의합니다.            (현재 인덱스의 팀원의 팀을 정해주고, 절반의 팀원이 포함될 때 까지 team함수를 호출하여 팀에 포함시킵니다. 
                                                                                                                                        해당 인덱스 팀원이 start에 포함된 경우로 모든 경우의 수를 검사하여 최소값을 구하고 return 됐을 때, 다음 경우의수를 검사하기 위해
                                                                                                                                        check[i]를 false로 다시 재정의함.)