1. 문제 인식

컴퓨터의 수와 각 컴퓨터가 네트워크 상에서 연결되어있는 정보가 주어질때, 1번 컴퓨터를 통해 바이러스에 걸리게 되는 컴퓨터의 수를 구하는 문제입니다.

2. 문제 유형 파악

컴퓨터들이 네트워크 상에서 서로 연결되어 있기 때문에, 이를 토대로 양방향 그래프를 작성할 수 있습니다.
따라서, 1번 컴퓨터부터 dfs를 하게되면 1번과 연결되는 컴퓨터들을 탐색하게 되므로, 바이러스에 감염된 컴퓨터 수를 구할 수 있습니다.
그러므로 이 문제는 dfs로 풀이합니다.

3. 다이어그램 또는 알고리즘을 나열

    1) 컴퓨터의 수를 저장할 정수형 변수 n과 컴퓨터 쌍의 수를 저장할 정수형 변수 network, 결과값을 저장할 정수형 변수 res를 선언합니다.
    2) 각 노드의 방문여부를 저장할 visited 1차원 배열과 인접리스트 graph를 생성합니다. (vector 1차원 배열)
    3) n과 network를 입력받습니다.
    4) i가 0부터 network - 1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
        (1) 컴퓨터 쌍의 시작점과 도착점을 저장할 start, end 정수형 변수를 선언합니다.
        (2) start와 end를 입력받습니다.
        (3) graph[start]에 end를 push합니다.
        (4) graph[end]에 start를 push합니다.                    (양방향 그래프이기 때문에, start, end 둘다 push)
    5) dfs(1)을 호출합니다.
    6) res를 출력합니다.

    dfs(int start)는 탐색시작지점인 start를 인자로 가지는 함수입니다.

    visited[start]가 false라면 visited[start]를 true로 정의합니다. (지금 방문했기 때문에 방문했다고 표기)
    현재 노드에 연결되어있는 리스트의 길이를 저장할 gSize를 선언하고 graph[start].size()로 정의합니다.
    i가 0부터 gSize - 1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
        다음 노드를 저장할 next 정수형 변수를 선언하고 graph[start][i]로 정의합니다.
        visited[next]가 false라면 다음을 수행합니다.
            visited[next]를 true로 정의합니다. (이제 방문할거니까)
            res에 1을 더합니다. (현재 start와 연결된 노드를 방문하는 것이기 때문에 이는 곧 바이러스에 걸리게됨.)
            dfs(next)를 호출합니다. (다음 노드 방문)