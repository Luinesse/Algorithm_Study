1. 문제 인식

수열의 크기 n을 입력받고 n의 길이의 수열 중 가장 긴 증가하는 부분 수열의 길이를 구하는 문제입니다.

2. 문제 유형 파악

이 문제는 시간 제한이 1초에 N이 최대 1000000까지 주어지므로, 기존 동적계획법으로는 O(N^2) 이므로 문제를 해결할 수 없습니다. 따라서 가장 긴 증가하는 부분 수열의 길이를 구하기 위해서 주어진 수열을 오름차순으로 채워나가면서 문제를 해결합니다.
왜냐하면, LIS는 반드시 오름차순으로 정렬되기 때문에 수를 입력받고 이진탐색을 통해 수의 자리만 찾아주면 오름차순 정렬이 가능하기 때문입니다. (기존 수보다 작은 수가 나왔다면 수를 교체함. 오름차순에서는 작은수로 바꿔주는게 더 긴 수열이 나올 가능성이 높기 때문.)

3. 다이어그램 또는 알고리즘을 나열

    1) 수열의 크기 n과 수를 입력 받기위한 정수형변수 tmp, 수가 수열에 삽입되어야 할 위치를 가리킬 idx 정수형 변수를 생성함. 이때, idx는 0으로 초기화.
    2) n을 입력받고 i가 0 부터 n-1까지 증가하며 반복하는 반복문에서 다음을 반복함.
        (1) tmp를 입력받음.
        (2) i가 현재 0이라면, tmp를 arr[0]에 삽입함.    (첫번째 수이기 때문에 당연히 제일 앞자리로 감.)
        (3) tmp가 arr[idx] 보다 크다면, arr[++idx]에 tmp를 삽입함. (idx 이하로는 이미 오름차순 정렬이 완료됨. 그러므로 idx 다음에 tmp를 넣으면 오름차순이 유지됨.)
        (4) (3)의 조건에 부합하지 못했다면, tmp값을 토대로 이진탐색을 거쳐 구해낸 인덱스값을 arr 인덱스 위치로하여 tmp를 삽입함.
    3) idx + 1을 출력함. (0부터 시작했기 때문에 1을 증가시켜줌.)


    이진탐색은 배열의 첫번째 인덱스(0)과 배열이 마지막으로 채워진 위치를 바탕으로 진행함. (tmp가 arr[idx]보다 작거나 같기 때문에 수를 교체해서 오름차순을 유지해야함.)
    이진탐색을 통해 tmp의 인덱스 위치를 찾게되면 그 인덱스 위치를 리턴함.