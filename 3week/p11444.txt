1. 문제 인식

n을 입력받고 피보나치 수열에서 n번째 수를 1000000007로 나눈 나머지를 구하는 문제입니다.

2. 문제 유형 파악

n이 long long int 형태로 주어지고, 시간 제한은 1초로 주어져서 동적계획법의 점화식으로는 O(N)이므로 N이 1억을 초과하는 문제에서 시간초과가 발생합니다. 따라서 기존의 선형 점화식을 행렬로 변환 후 행렬의 제곱은 O(log N)의 시간복잡도를 가지는 비선형 점화식으로 최적화된다는 점을 이용해 문제를 해결합니다.
        F(n+2) = F(n+1) + F(n)
                = [1, 1] * [[F(n+1)],[F(n)]]
        F(n+1) = F(n+1) + 0 * F(n)
                = [1, 0] * [[F(n+1)],[F(n)]]

        [[F(n+2)],[F(n+1)]] = [[1,1],[1,0]] * [[F(n+1)],[F(n)]]
            M(u+1)                  A               M(u)            로 가정
        M(0) = [[F(1)],[F(0)]] = [[1],[0]]          피보나치 수열의 1번째는 1, 0번째는 0이기 때문에 M(0)을 구할 수 있음.
        M(1) = A * M(0)
        M(2) = A * M(1) = A * (A * M(0)) = A^2 * M(0)
        따라서 M(n) = A^n * M(0)

        ex) [[F(8+1)],[F(8)]] = [[1, 1], [1, 0]]^8 * [[1][0]]
                                = [[34, 21], [21, 13]] * [[1][0]]
                                = [[34][21]]
                                F(9) = 34, F(8) = 21
                                
        위 식에서 A^n을 계산하면 [[F(n+1), F(n)], [F(n), F(n-1)]] 형태로 나옴. 그러므로 A. 즉 [[1, 1], [1, 0]]의 제곱식으로 피보나치 수열의 n번째 값을 구할 수 있음.
        F(n) = A^n 행렬의 0번째 행, 1번째 열.

        홀수의 경우, M^11 = M^5 * M^5 * M^1, M^5 = M^2 * M^2 * M^1, M^2 = M^1 * M^1 로 구할 수 있음. 이때 M^n = M^(n/2) * M^(n/2) * M^1 형태로 나오는걸 확인할 수 있음.
        짝수의 경우, M^10 = M^5 * M^5, M^5 = M^2 * M^2 * M^1, M^2 = M^1 * M^1 로 구할 수 있음. 이때 M^n = M^(n/2) * M^(n/2) 형태로 나오는걸 확인할 수 있음.
        위 식을 토대로 n/2로 분할하면서 1이 될때까지 내려간 후, 정복하는 과정을 통해 구할 수 있음. 2로 나누면서 분할하기 때문에 곱할 수가 줄어듬. 그러므로 O(log N)의 시간복잡도가 도출됨.
        따라서, 짝수는 M^(n/2) * M^(n/2) 이고, 홀수는 M^(n/2) * M^(n/2) * M^1 로 정의됨.

3. 다이어그램 또는 알고리즘을 나열

    1) 행렬 곱의 결과를 1000000007로 나눈 나머지를 저장해야하므로, 정수형 상수 mod에 저장.
    2) long long int 자료형으로 n을 정의하고, n을 입력받음.
    3) long long int 자료형을 담을 2*2 배열 A, tmp, ans를 정의함. 이때, A는 [[1, 1], [1, 0]] 으로 초기화하고 tmp는 모든 원소값을 1로 초기화함. (tmp는 제곱될 수이기 때문에 전부 1로 초기화. A는 피보나치 수열의 n번째 값을 구할 행렬)
    4) 인자로 A, tmp, res, n을 가지고 분할 정복을 이용하여 행렬곱을 수행하는 함수 conq를 호출함.
    5) ans[0][1]의 값을 출력함. (왜 ans[0][1]위치를 출력해야 하는지는 문제 유형 파악에서 서술함.)

    conq함수 구성은

        1) n이 1일때 A행렬을 ans행렬로 복사하고 리턴함. (A^1 이니까)
        2) n을 2로 나누면서 분할함.
        3) ans행렬의 값을 tmp행렬로 복사함. (이 조건문을 만났다는건 n이 이미 1이 됐었고 그렇다면 ans행렬은 A를 가지고 있음. 그걸 제곱해주어야 하므로 계산을 위한 tmp행렬로 복사.)
        4) tmp행렬의 제곱을 ans행렬에 저장. (행렬곱 과정에서 각 원소는 mod로 나눈 나머지를 저장.)
        5) 만일 n이 홀수일 경우, tmp행렬에 ans행렬값을 복사함.
        6) tmp행렬과 a행렬을 곱함. (이유는 문제 유형 파악에서 n이 홀수인 점화식에서 서술함.)
        7) tmp행렬에 ans행렬값을 복사함. (정복하는 과정에서 현재 결과값을 제곱하면서 정복해야하기 때문에.)