1. 문제 인식

N개의 도시가 P개의 단방향 길로 연결되어 있을 때, 1번도시와 2번도시로 가는 서로 다른 경로를 최대 개수를 찾아 출력하는 문제입니다.
단, 한 경로에 포함된 길은 다른 경로에 포함되면 안됩니다.

2. 문제 유형 파악

해당 문제는 1번에서 2번도시로 가는 경로를 최대한 많이 구하면되는 문제로, DFS로 해결하게 되면, 조건인 한 경로에 포함된 길을 다른 경로에서 중복하여 포함하는 문제가 발생합니다.
따라서, 에드몬즈-카프 알고리즘을 사용해 유량을 1로 제한하여 한 경로에 포함된 길이 다른 경로에 중복해서 포함되는 문제를 해결합니다.
그러므로 이문제는 에드몬즈-카프 알고리즘을 사용해 해결합니다.

3. 다이어그램 또는 알고리즘을 나열

    1) 도시의 수를 저장할 정수형 변수 n, 도로의 수를 저장할 정수형 변수 p, 결과를 저장할 정수형 변수 res를 선언합니다.
    2) 각 도로의 현재 유량을 저장할 2차원배열 flow, 각 도로의 최대용량을 저장할 2차원배열 capacity를 선언합니다.        (DFS 기준으로는 flow가 visted 배열과 비슷한 역할, why? 유량이 1이 최대. capacity로 최대 유량 1로 지정)
    3) 도로의 정보를 저장할 벡터 adj와 시작지점을 저장할 정수형 변수 src, 도착지점을 저장할 정수형 변수 dst를 선언합니다. 이때, 1번도시에서 2번도시로 가는 경로를 찾기 때문에 src는 1로, dst는 2로 초기화합니다.
    4) n, p를 입력받습니다.
    5) adj의 사이즈를 n + 1로 지정합니다.
    6) i가 0부터 p-1 까지 증가하며 반복하는 반복문에서 다음을 반복합니다.
        (1) 도로의 시작점과 도착점을 저장할 정수형 변수 from, to를 선언합니다.
        (2) from, to를 입력받습니다.
        (3) adj[from]에 to를 push합니다.
        (4) capacity[from][to]에 1을 대입합니다.        (from에서 to로 가는 간선은 최대 유량이 1.)
    7) edmonds() 함수를 호출합니다.
    8) ans를 출력합니다.

    edmonds 함수는 에드몬즈-카프 알고리즘을 수행하는 함수입니다.

        무한루프를 돌며 BFS 탐색을 시작합니다.
            BFS 탐색을 위한 큐 q를 선언합니다.
            큐에 src를 push합니다.
            이전에 지나온 노드를 저장할 벡터 parent를 선언합니다. 이때, 아직 방문하지 않은 노드의 구별을 위해 -1로 초기화합니다.
            경로 상에서 최소 유량을 저장할 변수 minFlow를 선언합니다. 초기값으로 아주 큰값으로 설정합니다.

            큐가 공백이 아니라면 반복하는 반복문에서 다음을 반복합니다. (정확하게는 여기 루프에서 BFS 탐색을 시작한다..)
                큐에서 front의 값을 cur 정수형 변수에 대입합니다.
                q.pop()을 수행합니다.

                루프마다 adj[cur]의 원소를 정수형 변수 next에 대입하는 반복문에서 다음을 반복합니다.        (adj[cur]의 원소를 대입하는 과정은 현재 도시와 이어진 도시에 대한 내용을 next 변수에 전달하는것.)
                    capacity[cur][next] - flow[cur][next]가 0보다 크고, parent[next]가 -1일때 다음을 수행합니다.        (다음도시가 아직 방문안됐을때. why ? 다음 도시의 최대유량에서 다음도시에 흐르고 있는 현재 유량을 뺐을 때, 0보다 크면 아직 흐를 수 있는 유량이 있음. 그리고 parent[next]도 -1인지 확인함. -1일때는 방문하지 않은 것이므로.)
                        큐에 next를 push합니다.
                        parent[next]에 cur을 대입합니다.                (다음 도시로 넘어가니까 현재 도시를 parent[next]에 저장 why? 다음 도시의 이전 노드를 저장해야하니까 parent[next]의 값이 cur이됨.)
                        next가 dst와 같을 경우 현재 반복문에서 탈출합니다.          (도착지점에 도달한 경우.)
            parent[dst] 가 -1일경우, 루프에서 탈출합니다.       (도착지점으로 가는 경로가 없음. 그러므로 루프종료. why? parent[dst]는 도착지점으로 가는 부모 노드가 있는지 보는 것인데, 없는 경우 -1로 초기화했다. 그러므로 도착지점으로 가는 간선이없는것. 찾을 필요가없음.)
            i가 dst부터 i가 src가 아닐 때, i를 parent[i]로 대입하는 반복문에서 다음을 반복합니다.
                minFlow에 minFlow와 capacity[parent[i]][i] - flow[parent[i]][i] 의 값 중 작은값을 대입합니다.       (지나온 경로의 최대 유량과 흘러온 유량의 차로 잔여 유량을 파악함. 그중 최소를 찾는다. why ? 가장 작은 잔여 유량에 맞추어야 다른 간선에서 포화되는 일이 없이 효율적으로 유량을 흘릴 수 있음.)
            i가 dst부터 i가 src가 아닐 때, i를 parent[i]로 대입하는 반복문에서 다음을 반복합니다.
                flow[parent[i]][i] 에 minFlow를 더합니다.
                flow[i][parent[i]] 에 minFlow를 뺍니다.                         (위에서 구한 최소 유량으로 음의 유량을 고려하는 부분. 순방향 경로로는 minFlow를 더하고 역방향 경로로는 minFlow를 빼줌.)
            ans에 minFlow를 더합니다.               (잔여 유량만큼 흘려보내면서 전체 네트워크의 최대 유량을 찾는과정.           즉, minFlow를 구하고, 그 값을 누적하면서 최대 유량을 찾음. why? 결국 그렇게해서 현재 찾은 최소 경로에서 흐를 수 있는 최대 유량이 나옴. 이걸 모든 최소 경로에서 수행하게 됐을 때, 전체 네트워크. 즉 출발점에서 도착지로 흐를 수 있는 최대 유량을 찾을 수 있음.)
