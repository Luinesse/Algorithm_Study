1. 문제 인식

무게 W와 가치 W를 가지는 N개의 물건을 K만큼의 무게를 담을 수 있는 배낭에 담을려고 할 때, 넣을 수 있는 물건들의 가치의 최대값을 구하는 문제입니다.

2. 문제 유형 파악

가방의 무게 K를 열로하고, 물건들을 행으로 할때, 표를 그리게 되면 다음과 같습니다. (입력으로 (6, 13), (4, 8), (3, 6), (5, 12) 로 주어진 예시)

    1  2  3  4  5  6  7 
0   0  0  0  0  0  0  0
1   0  0  0  0  0  13 13
2   0  0  0  8  8  13 13
3   0  0  6  8  8  13 14
4   0  0  6  8  12 13 14

첫번째 물건의 무게는 6, 가치는 13입니다. 따라서 무게 6을 담을 수 있는 배낭부터 담을 수 있습니다.
두번째 물건의 무게는 4, 가치는 8입니다. 따라서 무게 4를 담을 수 있는 배낭부터 담을 수 있습니다. 하지만 가치의 최대값을 구해야하므로, 무게 6을 담을 수 있는 배낭부터는 물건1을 담는게 가치가 높으니 물건 1을 담고 가치 13을 가집니다.
세번째 물건의 무게는 3, 가치는 6입니다. 따라서 무게 3을 담을 수 있는 배낭부터 담을 수 있습니다. 하지만 위와같은 이유로, 무게 4를 담을 수 있는 배낭부터 8을 담고, 무게 6을 담을 수 있는 배낭부터 13을 담습니다.
    하지만 무게 7인 배낭에는 세번째 물건과 두번째 물건 모두를 담을 수 있습니다. 따라서, 무게 7을 담을 수 있는 배낭에 물건 2,3 을 담고 가치 14를 가집니다.

위 예시를 통해 현재 i번째의 물건을 담을 수 없을 때, 바로 이전인 i - 1번째의 물건을 k무게를 담는 배낭에 담은 가치로 저장합니다. (이미 앞에서 가능하다고 계산했기에 가능함.) = dp[i - 1][j]
하지만 k가 i번째의 물건을 담을 수 있다고 했을 때, 현재 담고 있는 물건들의 무게를 배낭에서 빼고, 해당 물건을 담아 물건을 담기전과 비교하여 가치가 높은것을 선택합니다. = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

이는 1번 물건부터 계산하며 가치의 합을 갱신하면서 값을 채웠기 때문에, 아래서 물건을 두개 담을 수 있다면, 바로 전물건을 넣었을 때 가치에서 현재 물건을 넣은 가치를 구해 비교하는 방식으로 가치의 최대치를 갱신할 수 있습니다.
따라서 이 문제는 DP 알고리즘으로 문제를 해결합니다. (점화식은 위에서 서술되어있음. dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]))

3. 다이어그램 또는 알고리즘을 나열

    1) 물건의 수를 저장할 정수형 변수 n과 배낭의 무게를 저장할 정수형 변수 k, 결과값을 저장할 2차원배열 dp, 각 물건의 무게를 저장할 1차원배열 weight, 각 물건의 가치를 저장할 1차원 배열 value를 선언한다.
    2) n, k를 입력받는다.
    3) i가 1부터 n까지 증가하며 반복하는 반복문에서 weight[i], value[i]를 입력받는다.
    4) i가 1부터 n까지 증가하며 반복하는 반복문에서 다음을 반복한다.
        (1) j가 1부터 k까지 증가하며 반복하는 반복문에서 다음을 반복한다.
            [1] j - weight[i]가 0보다 크다면 dp[i][j] 에 max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) 의 리턴값을 대입한다.
            [2] [1]조건에 부합하지 않는다면 dp[i][j]에 dp[i - 1][j]를 대입한다.
    5) dp[n][k] 를 출력한다.